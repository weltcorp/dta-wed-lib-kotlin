// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: dta-wed-api/v1/questionnaires/questionnaires.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByUserIdRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int32 = 0

  public var limit: Int32 = 0

  public var page: Int32 = 0

  public var orderBy: String = String()

  public var asc: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswerSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var questionnaireID: Int32 = 0

  public var date: String = String()

  public var answerID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByUserIdResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var totalCount: Int32 = 0

  public var page: Int32 = 0

  public var count: Int32 = 0

  public var data: [Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswerSummary] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswerOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var questionnaireOptionID: Int32 = 0

  public var answerText: String = String()

  public var data: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var questionnaireItemID: Int32 = 0

  public var options: [Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswerOption] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Questionnaires_CreateQuestionnaireAnswersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var questionnaireID: Int32 = 0

  public var userID: Int32 = 0

  public var date: Int32 = 0

  public var answers: [Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswer] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Questionnaires_CreateQuestionnaireAnswersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireItemsByQuestionnaireIdRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var questionnaireID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Questionnaires_QuestionnaireItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var title: String = String()

  public var description_p: String = String()

  public var required: Bool = false

  public var status: Int32 = 0

  public var itemTypeID: Int32 = 0

  public var order: Int32 = 0

  public var options: [Dta_Wed_Api_V1_Questionnaires_QuestionnaireOption] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Questionnaires_QuestionnaireOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var title: String = String()

  public var order: Int32 = 0

  public var data: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _data ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireItemsByQuestionnaireIdResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var items: [Dta_Wed_Api_V1_Questionnaires_QuestionnaireItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByAnswerIdRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var answerID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Questionnaires_QuestionnaireItemAnswers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var itemID: Int32 = 0

  public var itemAnswers: [Dta_Wed_Api_V1_Questionnaires_QuestionnaireItemAnswer] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Questionnaires_QuestionnaireItemAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var optionID: Int32 = 0

  public var itemAnswerText: String = String()

  public var itemAnswerData: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _itemAnswerData ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_itemAnswerData = newValue}
  }
  /// Returns true if `itemAnswerData` has been explicitly set.
  public var hasItemAnswerData: Bool {return self._itemAnswerData != nil}
  /// Clears the value of `itemAnswerData`. Subsequent reads from it will return its default value.
  public mutating func clearItemAnswerData() {self._itemAnswerData = nil}

  public var itemAnswerID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _itemAnswerData: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByAnswerIdResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var date: String = String()

  public var answerID: Int32 = 0

  public var items: [Dta_Wed_Api_V1_Questionnaires_QuestionnaireItemAnswers] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Questionnaires_DeleteQuestionnaireAnswersByAnswerIdRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var answerID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByUserIdRequest: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswerSummary: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByUserIdResponse: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswerOption: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswer: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Questionnaires_CreateQuestionnaireAnswersRequest: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Questionnaires_CreateQuestionnaireAnswersResponse: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireItemsByQuestionnaireIdRequest: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Questionnaires_QuestionnaireItem: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Questionnaires_QuestionnaireOption: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireItemsByQuestionnaireIdResponse: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByAnswerIdRequest: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Questionnaires_QuestionnaireItemAnswers: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Questionnaires_QuestionnaireItemAnswer: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByAnswerIdResponse: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Questionnaires_DeleteQuestionnaireAnswersByAnswerIdRequest: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "dta.wed.api.v1.questionnaires"

extension Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByUserIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetQuestionnaireAnswersByUserIdRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "limit"),
    3: .same(proto: "page"),
    4: .same(proto: "orderBy"),
    5: .same(proto: "asc"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.asc) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 2)
    }
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 3)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 4)
    }
    if !self.asc.isEmpty {
      try visitor.visitSingularStringField(value: self.asc, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByUserIdRequest, rhs: Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByUserIdRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.page != rhs.page {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.asc != rhs.asc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswerSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionnaireAnswerSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "questionnaireId"),
    2: .same(proto: "date"),
    3: .same(proto: "answerId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.questionnaireID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.date) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.answerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.questionnaireID != 0 {
      try visitor.visitSingularInt32Field(value: self.questionnaireID, fieldNumber: 1)
    }
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 2)
    }
    if self.answerID != 0 {
      try visitor.visitSingularInt32Field(value: self.answerID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswerSummary, rhs: Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswerSummary) -> Bool {
    if lhs.questionnaireID != rhs.questionnaireID {return false}
    if lhs.date != rhs.date {return false}
    if lhs.answerID != rhs.answerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByUserIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetQuestionnaireAnswersByUserIdResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "totalCount"),
    2: .same(proto: "page"),
    3: .same(proto: "count"),
    4: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.totalCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalCount, fieldNumber: 1)
    }
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByUserIdResponse, rhs: Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByUserIdResponse) -> Bool {
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.page != rhs.page {return false}
    if lhs.count != rhs.count {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswerOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionnaireAnswerOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "questionnaireOptionId"),
    2: .same(proto: "answerText"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.questionnaireOptionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.answerText) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.questionnaireOptionID != 0 {
      try visitor.visitSingularInt32Field(value: self.questionnaireOptionID, fieldNumber: 1)
    }
    if !self.answerText.isEmpty {
      try visitor.visitSingularStringField(value: self.answerText, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswerOption, rhs: Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswerOption) -> Bool {
    if lhs.questionnaireOptionID != rhs.questionnaireOptionID {return false}
    if lhs.answerText != rhs.answerText {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionnaireAnswer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "questionnaireItemId"),
    2: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.questionnaireItemID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.questionnaireItemID != 0 {
      try visitor.visitSingularInt32Field(value: self.questionnaireItemID, fieldNumber: 1)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswer, rhs: Dta_Wed_Api_V1_Questionnaires_QuestionnaireAnswer) -> Bool {
    if lhs.questionnaireItemID != rhs.questionnaireItemID {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Questionnaires_CreateQuestionnaireAnswersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateQuestionnaireAnswersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "questionnaireId"),
    2: .same(proto: "userId"),
    3: .same(proto: "date"),
    4: .same(proto: "answers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.questionnaireID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.date) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.answers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.questionnaireID != 0 {
      try visitor.visitSingularInt32Field(value: self.questionnaireID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 2)
    }
    if self.date != 0 {
      try visitor.visitSingularInt32Field(value: self.date, fieldNumber: 3)
    }
    if !self.answers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.answers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Questionnaires_CreateQuestionnaireAnswersRequest, rhs: Dta_Wed_Api_V1_Questionnaires_CreateQuestionnaireAnswersRequest) -> Bool {
    if lhs.questionnaireID != rhs.questionnaireID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.date != rhs.date {return false}
    if lhs.answers != rhs.answers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Questionnaires_CreateQuestionnaireAnswersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateQuestionnaireAnswersResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Questionnaires_CreateQuestionnaireAnswersResponse, rhs: Dta_Wed_Api_V1_Questionnaires_CreateQuestionnaireAnswersResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireItemsByQuestionnaireIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetQuestionnaireItemsByQuestionnaireIdRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "questionnaireId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.questionnaireID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.questionnaireID != 0 {
      try visitor.visitSingularInt32Field(value: self.questionnaireID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireItemsByQuestionnaireIdRequest, rhs: Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireItemsByQuestionnaireIdRequest) -> Bool {
    if lhs.questionnaireID != rhs.questionnaireID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Questionnaires_QuestionnaireItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionnaireItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .same(proto: "description"),
    4: .same(proto: "required"),
    5: .same(proto: "status"),
    6: .same(proto: "itemTypeId"),
    7: .same(proto: "order"),
    10: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.required) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.itemTypeID) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.order) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.required != false {
      try visitor.visitSingularBoolField(value: self.required, fieldNumber: 4)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 5)
    }
    if self.itemTypeID != 0 {
      try visitor.visitSingularInt32Field(value: self.itemTypeID, fieldNumber: 6)
    }
    if self.order != 0 {
      try visitor.visitSingularInt32Field(value: self.order, fieldNumber: 7)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Questionnaires_QuestionnaireItem, rhs: Dta_Wed_Api_V1_Questionnaires_QuestionnaireItem) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.required != rhs.required {return false}
    if lhs.status != rhs.status {return false}
    if lhs.itemTypeID != rhs.itemTypeID {return false}
    if lhs.order != rhs.order {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Questionnaires_QuestionnaireOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionnaireOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .same(proto: "order"),
    4: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.order) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if self.order != 0 {
      try visitor.visitSingularInt32Field(value: self.order, fieldNumber: 3)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Questionnaires_QuestionnaireOption, rhs: Dta_Wed_Api_V1_Questionnaires_QuestionnaireOption) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.order != rhs.order {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireItemsByQuestionnaireIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetQuestionnaireItemsByQuestionnaireIdResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireItemsByQuestionnaireIdResponse, rhs: Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireItemsByQuestionnaireIdResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByAnswerIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetQuestionnaireAnswersByAnswerIdRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "answerId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.answerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.answerID != 0 {
      try visitor.visitSingularInt32Field(value: self.answerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByAnswerIdRequest, rhs: Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByAnswerIdRequest) -> Bool {
    if lhs.answerID != rhs.answerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Questionnaires_QuestionnaireItemAnswers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionnaireItemAnswers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "itemId"),
    2: .same(proto: "itemAnswers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.itemID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.itemAnswers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.itemID != 0 {
      try visitor.visitSingularInt32Field(value: self.itemID, fieldNumber: 1)
    }
    if !self.itemAnswers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.itemAnswers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Questionnaires_QuestionnaireItemAnswers, rhs: Dta_Wed_Api_V1_Questionnaires_QuestionnaireItemAnswers) -> Bool {
    if lhs.itemID != rhs.itemID {return false}
    if lhs.itemAnswers != rhs.itemAnswers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Questionnaires_QuestionnaireItemAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionnaireItemAnswer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "optionId"),
    2: .same(proto: "itemAnswerText"),
    3: .same(proto: "itemAnswerData"),
    4: .same(proto: "itemAnswerId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.optionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.itemAnswerText) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._itemAnswerData) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.itemAnswerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.optionID != 0 {
      try visitor.visitSingularInt32Field(value: self.optionID, fieldNumber: 1)
    }
    if !self.itemAnswerText.isEmpty {
      try visitor.visitSingularStringField(value: self.itemAnswerText, fieldNumber: 2)
    }
    try { if let v = self._itemAnswerData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.itemAnswerID != 0 {
      try visitor.visitSingularInt32Field(value: self.itemAnswerID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Questionnaires_QuestionnaireItemAnswer, rhs: Dta_Wed_Api_V1_Questionnaires_QuestionnaireItemAnswer) -> Bool {
    if lhs.optionID != rhs.optionID {return false}
    if lhs.itemAnswerText != rhs.itemAnswerText {return false}
    if lhs._itemAnswerData != rhs._itemAnswerData {return false}
    if lhs.itemAnswerID != rhs.itemAnswerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByAnswerIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetQuestionnaireAnswersByAnswerIdResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "answerId"),
    3: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.date) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.answerID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 1)
    }
    if self.answerID != 0 {
      try visitor.visitSingularInt32Field(value: self.answerID, fieldNumber: 2)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByAnswerIdResponse, rhs: Dta_Wed_Api_V1_Questionnaires_GetQuestionnaireAnswersByAnswerIdResponse) -> Bool {
    if lhs.date != rhs.date {return false}
    if lhs.answerID != rhs.answerID {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Questionnaires_DeleteQuestionnaireAnswersByAnswerIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteQuestionnaireAnswersByAnswerIdRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "answerId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.answerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.answerID != 0 {
      try visitor.visitSingularInt32Field(value: self.answerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Questionnaires_DeleteQuestionnaireAnswersByAnswerIdRequest, rhs: Dta_Wed_Api_V1_Questionnaires_DeleteQuestionnaireAnswersByAnswerIdRequest) -> Bool {
    if lhs.answerID != rhs.answerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
