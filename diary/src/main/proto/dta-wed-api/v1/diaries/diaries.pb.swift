// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: dta-wed-api/v1/diaries/diaries.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Dta_Wed_Api_V1_Diaries_GetUserDiariesByDateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int32 = 0

  public var date: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Diaries_MealDiarySchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enabled: Bool = false

  public var when: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Diaries_MealDiary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var status: Int32 = 0

  public var mealTime: String = String()

  public var emotion: Int32 = 0

  public var body: String = String()

  public var answerID: Int32 {
    get {return _answerID ?? 0}
    set {_answerID = newValue}
  }
  /// Returns true if `answerID` has been explicitly set.
  public var hasAnswerID: Bool {return self._answerID != nil}
  /// Clears the value of `answerID`. Subsequent reads from it will return its default value.
  public mutating func clearAnswerID() {self._answerID = nil}

  public var schedule: Dta_Wed_Api_V1_Diaries_MealDiarySchedule {
    get {return _schedule ?? Dta_Wed_Api_V1_Diaries_MealDiarySchedule()}
    set {_schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  public var hasSchedule: Bool {return self._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  public mutating func clearSchedule() {self._schedule = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _answerID: Int32? = nil
  fileprivate var _schedule: Dta_Wed_Api_V1_Diaries_MealDiarySchedule? = nil
}

public struct Dta_Wed_Api_V1_Diaries_GetUserDiariesByDateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: [Dta_Wed_Api_V1_Diaries_MealDiary] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Diaries_GetUserDiaryCalendarRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int32 = 0

  public var startDate: Int32 = 0

  public var endDate: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Diaries_CalendarDiary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var diaryID: Int32 = 0

  public var answer: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Diaries_UserDiaryCalendar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var date: String = String()

  public var diaries: [Dta_Wed_Api_V1_Diaries_CalendarDiary] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Diaries_GetUserDiaryCalendarResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: [Dta_Wed_Api_V1_Diaries_UserDiaryCalendar] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Diaries_GetDiaryByIdRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var diaryID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Diaries_DiaryItemOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var title: String = String()

  public var index: Int32 = 0

  public var memo: String = String()

  public var diaryItemID: Int32 = 0

  public var data: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _data ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var order: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Dta_Wed_Api_V1_Diaries_DiaryItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var title: String = String()

  public var description_p: String = String()

  public var required: Bool = false

  public var url: String = String()

  public var memo: String = String()

  public var diaryID: Int32 = 0

  public var diaryStatusID: Int32 = 0

  public var itemTypeID: Int32 = 0

  public var order: Int32 = 0

  public var data: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _data ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var options: [Dta_Wed_Api_V1_Diaries_DiaryItemOption] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Dta_Wed_Api_V1_Diaries_GetDiaryByIdResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var items: [Dta_Wed_Api_V1_Diaries_DiaryItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Diaries_DiaryAnswerOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var diaryOptionID: Int32 = 0

  public var answerText: String = String()

  public var data: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _data ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Dta_Wed_Api_V1_Diaries_DiaryAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var diaryItemID: Int32 = 0

  public var options: [Dta_Wed_Api_V1_Diaries_DiaryAnswerOption] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Diaries_UpsertDiaryAnswersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var diaryID: Int32 = 0

  public var userID: Int32 = 0

  public var date: Int32 = 0

  public var answers: [Dta_Wed_Api_V1_Diaries_DiaryAnswer] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Diaries_CreateDiaryAnswersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var diaryID: Int32 = 0

  public var userID: Int32 = 0

  public var date: Int32 = 0

  public var answers: [Dta_Wed_Api_V1_Diaries_DiaryAnswer] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Diaries_UpdateDiaryAnswersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var answerID: Int32 = 0

  public var date: Int32 = 0

  public var answers: [Dta_Wed_Api_V1_Diaries_DiaryAnswer] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Diaries_DeleteDiaryAnswersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var answerID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Diaries_GetDiaryAnswerByAnswerIdRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var answerID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Diaries_DiaryItemAnswers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var itemID: Int32 = 0

  public var itemAnswers: [Dta_Wed_Api_V1_Diaries_DiaryItemAnswer] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V1_Diaries_DiaryItemAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var optionID: Int32 = 0

  public var diaryItemAnswerText: String = String()

  public var diaryItemAnswerData: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _diaryItemAnswerData ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_diaryItemAnswerData = newValue}
  }
  /// Returns true if `diaryItemAnswerData` has been explicitly set.
  public var hasDiaryItemAnswerData: Bool {return self._diaryItemAnswerData != nil}
  /// Clears the value of `diaryItemAnswerData`. Subsequent reads from it will return its default value.
  public mutating func clearDiaryItemAnswerData() {self._diaryItemAnswerData = nil}

  public var diaryItemAnswerID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _diaryItemAnswerData: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Dta_Wed_Api_V1_Diaries_GetDiaryAnswerByAnswerIdResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var date: String = String()

  public var answerID: Int32 = 0

  public var items: [Dta_Wed_Api_V1_Diaries_DiaryItemAnswers] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Dta_Wed_Api_V1_Diaries_GetUserDiariesByDateRequest: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_MealDiarySchedule: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_MealDiary: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_GetUserDiariesByDateResponse: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_GetUserDiaryCalendarRequest: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_CalendarDiary: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_UserDiaryCalendar: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_GetUserDiaryCalendarResponse: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_GetDiaryByIdRequest: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_DiaryItemOption: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_DiaryItem: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_GetDiaryByIdResponse: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_DiaryAnswerOption: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_DiaryAnswer: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_UpsertDiaryAnswersRequest: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_CreateDiaryAnswersRequest: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_UpdateDiaryAnswersRequest: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_DeleteDiaryAnswersRequest: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_GetDiaryAnswerByAnswerIdRequest: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_DiaryItemAnswers: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_DiaryItemAnswer: @unchecked Sendable {}
extension Dta_Wed_Api_V1_Diaries_GetDiaryAnswerByAnswerIdResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "dta.wed.api.v1.diaries"

extension Dta_Wed_Api_V1_Diaries_GetUserDiariesByDateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserDiariesByDateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if self.date != 0 {
      try visitor.visitSingularInt32Field(value: self.date, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_GetUserDiariesByDateRequest, rhs: Dta_Wed_Api_V1_Diaries_GetUserDiariesByDateRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_MealDiarySchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MealDiarySchedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "when"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.when) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if !self.when.isEmpty {
      try visitor.visitSingularStringField(value: self.when, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_MealDiarySchedule, rhs: Dta_Wed_Api_V1_Diaries_MealDiarySchedule) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.when != rhs.when {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_MealDiary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MealDiary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "status"),
    3: .same(proto: "mealTime"),
    4: .same(proto: "emotion"),
    5: .same(proto: "body"),
    6: .same(proto: "answerId"),
    7: .same(proto: "schedule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mealTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.emotion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.body) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._answerID) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 2)
    }
    if !self.mealTime.isEmpty {
      try visitor.visitSingularStringField(value: self.mealTime, fieldNumber: 3)
    }
    if self.emotion != 0 {
      try visitor.visitSingularInt32Field(value: self.emotion, fieldNumber: 4)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularStringField(value: self.body, fieldNumber: 5)
    }
    try { if let v = self._answerID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_MealDiary, rhs: Dta_Wed_Api_V1_Diaries_MealDiary) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.status != rhs.status {return false}
    if lhs.mealTime != rhs.mealTime {return false}
    if lhs.emotion != rhs.emotion {return false}
    if lhs.body != rhs.body {return false}
    if lhs._answerID != rhs._answerID {return false}
    if lhs._schedule != rhs._schedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_GetUserDiariesByDateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserDiariesByDateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_GetUserDiariesByDateResponse, rhs: Dta_Wed_Api_V1_Diaries_GetUserDiariesByDateResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_GetUserDiaryCalendarRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserDiaryCalendarRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "startDate"),
    3: .same(proto: "endDate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.startDate) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.endDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if self.startDate != 0 {
      try visitor.visitSingularInt32Field(value: self.startDate, fieldNumber: 2)
    }
    if self.endDate != 0 {
      try visitor.visitSingularInt32Field(value: self.endDate, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_GetUserDiaryCalendarRequest, rhs: Dta_Wed_Api_V1_Diaries_GetUserDiaryCalendarRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.startDate != rhs.startDate {return false}
    if lhs.endDate != rhs.endDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_CalendarDiary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CalendarDiary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "diaryId"),
    2: .same(proto: "answer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.diaryID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.answer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.diaryID != 0 {
      try visitor.visitSingularInt32Field(value: self.diaryID, fieldNumber: 1)
    }
    if self.answer != false {
      try visitor.visitSingularBoolField(value: self.answer, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_CalendarDiary, rhs: Dta_Wed_Api_V1_Diaries_CalendarDiary) -> Bool {
    if lhs.diaryID != rhs.diaryID {return false}
    if lhs.answer != rhs.answer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_UserDiaryCalendar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserDiaryCalendar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "diaries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.date) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.diaries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 1)
    }
    if !self.diaries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.diaries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_UserDiaryCalendar, rhs: Dta_Wed_Api_V1_Diaries_UserDiaryCalendar) -> Bool {
    if lhs.date != rhs.date {return false}
    if lhs.diaries != rhs.diaries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_GetUserDiaryCalendarResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserDiaryCalendarResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_GetUserDiaryCalendarResponse, rhs: Dta_Wed_Api_V1_Diaries_GetUserDiaryCalendarResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_GetDiaryByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDiaryByIdRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "diaryId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.diaryID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.diaryID != 0 {
      try visitor.visitSingularInt32Field(value: self.diaryID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_GetDiaryByIdRequest, rhs: Dta_Wed_Api_V1_Diaries_GetDiaryByIdRequest) -> Bool {
    if lhs.diaryID != rhs.diaryID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_DiaryItemOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiaryItemOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .same(proto: "index"),
    5: .same(proto: "memo"),
    8: .same(proto: "diaryItemId"),
    9: .same(proto: "data"),
    12: .same(proto: "order"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.memo) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.diaryItemID) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.order) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 3)
    }
    if !self.memo.isEmpty {
      try visitor.visitSingularStringField(value: self.memo, fieldNumber: 5)
    }
    if self.diaryItemID != 0 {
      try visitor.visitSingularInt32Field(value: self.diaryItemID, fieldNumber: 8)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if self.order != 0 {
      try visitor.visitSingularInt32Field(value: self.order, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_DiaryItemOption, rhs: Dta_Wed_Api_V1_Diaries_DiaryItemOption) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.index != rhs.index {return false}
    if lhs.memo != rhs.memo {return false}
    if lhs.diaryItemID != rhs.diaryItemID {return false}
    if lhs._data != rhs._data {return false}
    if lhs.order != rhs.order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_DiaryItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiaryItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .same(proto: "description"),
    4: .same(proto: "required"),
    5: .same(proto: "url"),
    6: .same(proto: "memo"),
    9: .same(proto: "diaryId"),
    10: .same(proto: "diaryStatusId"),
    11: .same(proto: "itemTypeId"),
    12: .same(proto: "order"),
    13: .same(proto: "data"),
    14: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.required) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.memo) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.diaryID) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.diaryStatusID) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.itemTypeID) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.order) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.required != false {
      try visitor.visitSingularBoolField(value: self.required, fieldNumber: 4)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 5)
    }
    if !self.memo.isEmpty {
      try visitor.visitSingularStringField(value: self.memo, fieldNumber: 6)
    }
    if self.diaryID != 0 {
      try visitor.visitSingularInt32Field(value: self.diaryID, fieldNumber: 9)
    }
    if self.diaryStatusID != 0 {
      try visitor.visitSingularInt32Field(value: self.diaryStatusID, fieldNumber: 10)
    }
    if self.itemTypeID != 0 {
      try visitor.visitSingularInt32Field(value: self.itemTypeID, fieldNumber: 11)
    }
    if self.order != 0 {
      try visitor.visitSingularInt32Field(value: self.order, fieldNumber: 12)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_DiaryItem, rhs: Dta_Wed_Api_V1_Diaries_DiaryItem) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.required != rhs.required {return false}
    if lhs.url != rhs.url {return false}
    if lhs.memo != rhs.memo {return false}
    if lhs.diaryID != rhs.diaryID {return false}
    if lhs.diaryStatusID != rhs.diaryStatusID {return false}
    if lhs.itemTypeID != rhs.itemTypeID {return false}
    if lhs.order != rhs.order {return false}
    if lhs._data != rhs._data {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_GetDiaryByIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDiaryByIdResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_GetDiaryByIdResponse, rhs: Dta_Wed_Api_V1_Diaries_GetDiaryByIdResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_DiaryAnswerOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiaryAnswerOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "diaryOptionId"),
    2: .same(proto: "answerText"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.diaryOptionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.answerText) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.diaryOptionID != 0 {
      try visitor.visitSingularInt32Field(value: self.diaryOptionID, fieldNumber: 1)
    }
    if !self.answerText.isEmpty {
      try visitor.visitSingularStringField(value: self.answerText, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_DiaryAnswerOption, rhs: Dta_Wed_Api_V1_Diaries_DiaryAnswerOption) -> Bool {
    if lhs.diaryOptionID != rhs.diaryOptionID {return false}
    if lhs.answerText != rhs.answerText {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_DiaryAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiaryAnswer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "diaryItemId"),
    2: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.diaryItemID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.diaryItemID != 0 {
      try visitor.visitSingularInt32Field(value: self.diaryItemID, fieldNumber: 1)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_DiaryAnswer, rhs: Dta_Wed_Api_V1_Diaries_DiaryAnswer) -> Bool {
    if lhs.diaryItemID != rhs.diaryItemID {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_UpsertDiaryAnswersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpsertDiaryAnswersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "diaryId"),
    2: .same(proto: "userId"),
    3: .same(proto: "date"),
    4: .same(proto: "answers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.diaryID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.date) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.answers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.diaryID != 0 {
      try visitor.visitSingularInt32Field(value: self.diaryID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 2)
    }
    if self.date != 0 {
      try visitor.visitSingularInt32Field(value: self.date, fieldNumber: 3)
    }
    if !self.answers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.answers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_UpsertDiaryAnswersRequest, rhs: Dta_Wed_Api_V1_Diaries_UpsertDiaryAnswersRequest) -> Bool {
    if lhs.diaryID != rhs.diaryID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.date != rhs.date {return false}
    if lhs.answers != rhs.answers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_CreateDiaryAnswersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDiaryAnswersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "diaryId"),
    2: .same(proto: "userId"),
    3: .same(proto: "date"),
    4: .same(proto: "answers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.diaryID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.date) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.answers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.diaryID != 0 {
      try visitor.visitSingularInt32Field(value: self.diaryID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 2)
    }
    if self.date != 0 {
      try visitor.visitSingularInt32Field(value: self.date, fieldNumber: 3)
    }
    if !self.answers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.answers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_CreateDiaryAnswersRequest, rhs: Dta_Wed_Api_V1_Diaries_CreateDiaryAnswersRequest) -> Bool {
    if lhs.diaryID != rhs.diaryID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.date != rhs.date {return false}
    if lhs.answers != rhs.answers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_UpdateDiaryAnswersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateDiaryAnswersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "answerId"),
    3: .same(proto: "date"),
    4: .same(proto: "answers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.answerID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.date) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.answers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.answerID != 0 {
      try visitor.visitSingularInt32Field(value: self.answerID, fieldNumber: 1)
    }
    if self.date != 0 {
      try visitor.visitSingularInt32Field(value: self.date, fieldNumber: 3)
    }
    if !self.answers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.answers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_UpdateDiaryAnswersRequest, rhs: Dta_Wed_Api_V1_Diaries_UpdateDiaryAnswersRequest) -> Bool {
    if lhs.answerID != rhs.answerID {return false}
    if lhs.date != rhs.date {return false}
    if lhs.answers != rhs.answers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_DeleteDiaryAnswersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteDiaryAnswersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "answerId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.answerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.answerID != 0 {
      try visitor.visitSingularInt32Field(value: self.answerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_DeleteDiaryAnswersRequest, rhs: Dta_Wed_Api_V1_Diaries_DeleteDiaryAnswersRequest) -> Bool {
    if lhs.answerID != rhs.answerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_GetDiaryAnswerByAnswerIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDiaryAnswerByAnswerIdRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "answerId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.answerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.answerID != 0 {
      try visitor.visitSingularInt32Field(value: self.answerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_GetDiaryAnswerByAnswerIdRequest, rhs: Dta_Wed_Api_V1_Diaries_GetDiaryAnswerByAnswerIdRequest) -> Bool {
    if lhs.answerID != rhs.answerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_DiaryItemAnswers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiaryItemAnswers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "itemId"),
    2: .same(proto: "itemAnswers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.itemID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.itemAnswers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.itemID != 0 {
      try visitor.visitSingularInt32Field(value: self.itemID, fieldNumber: 1)
    }
    if !self.itemAnswers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.itemAnswers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_DiaryItemAnswers, rhs: Dta_Wed_Api_V1_Diaries_DiaryItemAnswers) -> Bool {
    if lhs.itemID != rhs.itemID {return false}
    if lhs.itemAnswers != rhs.itemAnswers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_DiaryItemAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiaryItemAnswer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "optionId"),
    2: .same(proto: "diaryItemAnswerText"),
    3: .same(proto: "diaryItemAnswerData"),
    4: .same(proto: "diaryItemAnswerId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.optionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.diaryItemAnswerText) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._diaryItemAnswerData) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.diaryItemAnswerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.optionID != 0 {
      try visitor.visitSingularInt32Field(value: self.optionID, fieldNumber: 1)
    }
    if !self.diaryItemAnswerText.isEmpty {
      try visitor.visitSingularStringField(value: self.diaryItemAnswerText, fieldNumber: 2)
    }
    try { if let v = self._diaryItemAnswerData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.diaryItemAnswerID != 0 {
      try visitor.visitSingularInt32Field(value: self.diaryItemAnswerID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_DiaryItemAnswer, rhs: Dta_Wed_Api_V1_Diaries_DiaryItemAnswer) -> Bool {
    if lhs.optionID != rhs.optionID {return false}
    if lhs.diaryItemAnswerText != rhs.diaryItemAnswerText {return false}
    if lhs._diaryItemAnswerData != rhs._diaryItemAnswerData {return false}
    if lhs.diaryItemAnswerID != rhs.diaryItemAnswerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V1_Diaries_GetDiaryAnswerByAnswerIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDiaryAnswerByAnswerIdResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "answerId"),
    3: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.date) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.answerID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 1)
    }
    if self.answerID != 0 {
      try visitor.visitSingularInt32Field(value: self.answerID, fieldNumber: 2)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V1_Diaries_GetDiaryAnswerByAnswerIdResponse, rhs: Dta_Wed_Api_V1_Diaries_GetDiaryAnswerByAnswerIdResponse) -> Bool {
    if lhs.date != rhs.date {return false}
    if lhs.answerID != rhs.answerID {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
