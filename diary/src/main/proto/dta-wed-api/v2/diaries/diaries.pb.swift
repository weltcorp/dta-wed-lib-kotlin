// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: dta-wed-api/v2/diaries/diaries.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Dta_Wed_Api_V2_Diaries_DiaryFood {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {self._text = nil}

  public var uriList: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _text: String? = nil
}

public struct Dta_Wed_Api_V2_Diaries_DiaryFeelingEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {self._text = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _text: String? = nil
}

public struct Dta_Wed_Api_V2_Diaries_DiaryFeeling {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var score: Int32 = 0

  public var event: Dta_Wed_Api_V2_Diaries_DiaryFeelingEvent {
    get {return _event ?? Dta_Wed_Api_V2_Diaries_DiaryFeelingEvent()}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  public var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  public mutating func clearEvent() {self._event = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _event: Dta_Wed_Api_V2_Diaries_DiaryFeelingEvent? = nil
}

public struct Dta_Wed_Api_V2_Diaries_DiaryFeelingScore {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var score: Int32 {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  public var event: Int32 {
    get {return _event ?? 0}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  public var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  public mutating func clearEvent() {self._event = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Int32? = nil
  fileprivate var _event: Int32? = nil
}

public struct Dta_Wed_Api_V2_Diaries_DiarySchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enabled: Bool = false

  public var time: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V2_Diaries_DiaryMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var type: Int32 = 0

  public var title: String = String()

  public var description_p: String = String()

  public var emotion: Int32 {
    get {return _emotion ?? 0}
    set {_emotion = newValue}
  }
  /// Returns true if `emotion` has been explicitly set.
  public var hasEmotion: Bool {return self._emotion != nil}
  /// Clears the value of `emotion`. Subsequent reads from it will return its default value.
  public mutating func clearEmotion() {self._emotion = nil}

  public var schedule: Dta_Wed_Api_V2_Diaries_DiarySchedule {
    get {return _schedule ?? Dta_Wed_Api_V2_Diaries_DiarySchedule()}
    set {_schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  public var hasSchedule: Bool {return self._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  public mutating func clearSchedule() {self._schedule = nil}

  public var date: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _emotion: Int32? = nil
  fileprivate var _schedule: Dta_Wed_Api_V2_Diaries_DiarySchedule? = nil
}

public struct Dta_Wed_Api_V2_Diaries_DiaryData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Int32 = 0

  public var time: String {
    get {return _time ?? String()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  public var who: [Int32] = []

  public var `where`: Int32 {
    get {return _where ?? 0}
    set {_where = newValue}
  }
  /// Returns true if ``where`` has been explicitly set.
  public var hasWhere: Bool {return self._where != nil}
  /// Clears the value of ``where``. Subsequent reads from it will return its default value.
  public mutating func clearWhere() {self._where = nil}

  public var food: Dta_Wed_Api_V2_Diaries_DiaryFood {
    get {return _food ?? Dta_Wed_Api_V2_Diaries_DiaryFood()}
    set {_food = newValue}
  }
  /// Returns true if `food` has been explicitly set.
  public var hasFood: Bool {return self._food != nil}
  /// Clears the value of `food`. Subsequent reads from it will return its default value.
  public mutating func clearFood() {self._food = nil}

  public var beforeHungryScore: Int32 {
    get {return _beforeHungryScore ?? 0}
    set {_beforeHungryScore = newValue}
  }
  /// Returns true if `beforeHungryScore` has been explicitly set.
  public var hasBeforeHungryScore: Bool {return self._beforeHungryScore != nil}
  /// Clears the value of `beforeHungryScore`. Subsequent reads from it will return its default value.
  public mutating func clearBeforeHungryScore() {self._beforeHungryScore = nil}

  public var afterHungryScore: Int32 {
    get {return _afterHungryScore ?? 0}
    set {_afterHungryScore = newValue}
  }
  /// Returns true if `afterHungryScore` has been explicitly set.
  public var hasAfterHungryScore: Bool {return self._afterHungryScore != nil}
  /// Clears the value of `afterHungryScore`. Subsequent reads from it will return its default value.
  public mutating func clearAfterHungryScore() {self._afterHungryScore = nil}

  public var feeling: Dta_Wed_Api_V2_Diaries_DiaryFeeling {
    get {return _feeling ?? Dta_Wed_Api_V2_Diaries_DiaryFeeling()}
    set {_feeling = newValue}
  }
  /// Returns true if `feeling` has been explicitly set.
  public var hasFeeling: Bool {return self._feeling != nil}
  /// Clears the value of `feeling`. Subsequent reads from it will return its default value.
  public mutating func clearFeeling() {self._feeling = nil}

  public var mistakes: [Int32] = []

  public var isSkip: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: String? = nil
  fileprivate var _where: Int32? = nil
  fileprivate var _food: Dta_Wed_Api_V2_Diaries_DiaryFood? = nil
  fileprivate var _beforeHungryScore: Int32? = nil
  fileprivate var _afterHungryScore: Int32? = nil
  fileprivate var _feeling: Dta_Wed_Api_V2_Diaries_DiaryFeeling? = nil
}

public struct Dta_Wed_Api_V2_Diaries_Diary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var meta: Dta_Wed_Api_V2_Diaries_DiaryMeta {
    get {return _storage._meta ?? Dta_Wed_Api_V2_Diaries_DiaryMeta()}
    set {_uniqueStorage()._meta = newValue}
  }
  /// Returns true if `meta` has been explicitly set.
  public var hasMeta: Bool {return _storage._meta != nil}
  /// Clears the value of `meta`. Subsequent reads from it will return its default value.
  public mutating func clearMeta() {_uniqueStorage()._meta = nil}

  public var data: Dta_Wed_Api_V2_Diaries_DiaryData {
    get {return _storage._data ?? Dta_Wed_Api_V2_Diaries_DiaryData()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Dta_Wed_Api_V2_Diaries_CreateDiaryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var date: Int32 = 0

  public var data: Dta_Wed_Api_V2_Diaries_DiaryData {
    get {return _data ?? Dta_Wed_Api_V2_Diaries_DiaryData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Dta_Wed_Api_V2_Diaries_DiaryData? = nil
}

public struct Dta_Wed_Api_V2_Diaries_UpdateDiaryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var data: Dta_Wed_Api_V2_Diaries_DiaryData {
    get {return _data ?? Dta_Wed_Api_V2_Diaries_DiaryData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Dta_Wed_Api_V2_Diaries_DiaryData? = nil
}

public struct Dta_Wed_Api_V2_Diaries_GetDiariesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var date: Int32 = 0

  public var startDate: Int32 = 0

  public var endDate: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dta_Wed_Api_V2_Diaries_GetDiariesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startDate: Int32 = 0

  public var endDate: Int32 = 0

  public var diaries: [Dta_Wed_Api_V2_Diaries_Diary] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Dta_Wed_Api_V2_Diaries_DiaryFood: @unchecked Sendable {}
extension Dta_Wed_Api_V2_Diaries_DiaryFeelingEvent: @unchecked Sendable {}
extension Dta_Wed_Api_V2_Diaries_DiaryFeeling: @unchecked Sendable {}
extension Dta_Wed_Api_V2_Diaries_DiaryFeelingScore: @unchecked Sendable {}
extension Dta_Wed_Api_V2_Diaries_DiarySchedule: @unchecked Sendable {}
extension Dta_Wed_Api_V2_Diaries_DiaryMeta: @unchecked Sendable {}
extension Dta_Wed_Api_V2_Diaries_DiaryData: @unchecked Sendable {}
extension Dta_Wed_Api_V2_Diaries_Diary: @unchecked Sendable {}
extension Dta_Wed_Api_V2_Diaries_CreateDiaryRequest: @unchecked Sendable {}
extension Dta_Wed_Api_V2_Diaries_UpdateDiaryRequest: @unchecked Sendable {}
extension Dta_Wed_Api_V2_Diaries_GetDiariesRequest: @unchecked Sendable {}
extension Dta_Wed_Api_V2_Diaries_GetDiariesResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "dta.wed.api.v2.diaries"

extension Dta_Wed_Api_V2_Diaries_DiaryFood: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiaryFood"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "uriList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.uriList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.uriList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.uriList, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V2_Diaries_DiaryFood, rhs: Dta_Wed_Api_V2_Diaries_DiaryFood) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs.uriList != rhs.uriList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V2_Diaries_DiaryFeelingEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiaryFeelingEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V2_Diaries_DiaryFeelingEvent, rhs: Dta_Wed_Api_V2_Diaries_DiaryFeelingEvent) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._text != rhs._text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V2_Diaries_DiaryFeeling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiaryFeeling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.score) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.score != 0 {
      try visitor.visitSingularInt32Field(value: self.score, fieldNumber: 1)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V2_Diaries_DiaryFeeling, rhs: Dta_Wed_Api_V2_Diaries_DiaryFeeling) -> Bool {
    if lhs.score != rhs.score {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V2_Diaries_DiaryFeelingScore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiaryFeelingScore"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._score) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V2_Diaries_DiaryFeelingScore, rhs: Dta_Wed_Api_V2_Diaries_DiaryFeelingScore) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V2_Diaries_DiarySchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiarySchedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if !self.time.isEmpty {
      try visitor.visitSingularStringField(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V2_Diaries_DiarySchedule, rhs: Dta_Wed_Api_V2_Diaries_DiarySchedule) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V2_Diaries_DiaryMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiaryMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "title"),
    4: .same(proto: "description"),
    5: .same(proto: "emotion"),
    6: .same(proto: "schedule"),
    7: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._emotion) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    try { if let v = self._emotion {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.date != 0 {
      try visitor.visitSingularInt32Field(value: self.date, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V2_Diaries_DiaryMeta, rhs: Dta_Wed_Api_V2_Diaries_DiaryMeta) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._emotion != rhs._emotion {return false}
    if lhs._schedule != rhs._schedule {return false}
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V2_Diaries_DiaryData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiaryData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "type"),
    5: .same(proto: "time"),
    6: .same(proto: "who"),
    7: .same(proto: "where"),
    8: .same(proto: "food"),
    9: .same(proto: "beforeHungryScore"),
    10: .same(proto: "afterHungryScore"),
    11: .same(proto: "feeling"),
    12: .same(proto: "mistakes"),
    13: .same(proto: "isSkip"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._time) }()
      case 6: try { try decoder.decodeRepeatedInt32Field(value: &self.who) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._where) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._food) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self._beforeHungryScore) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self._afterHungryScore) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._feeling) }()
      case 12: try { try decoder.decodeRepeatedInt32Field(value: &self.mistakes) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.isSkip) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 2)
    }
    try { if let v = self._time {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    if !self.who.isEmpty {
      try visitor.visitPackedInt32Field(value: self.who, fieldNumber: 6)
    }
    try { if let v = self._where {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._food {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._beforeHungryScore {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._afterHungryScore {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._feeling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    if !self.mistakes.isEmpty {
      try visitor.visitPackedInt32Field(value: self.mistakes, fieldNumber: 12)
    }
    if self.isSkip != false {
      try visitor.visitSingularBoolField(value: self.isSkip, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V2_Diaries_DiaryData, rhs: Dta_Wed_Api_V2_Diaries_DiaryData) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._time != rhs._time {return false}
    if lhs.who != rhs.who {return false}
    if lhs._where != rhs._where {return false}
    if lhs._food != rhs._food {return false}
    if lhs._beforeHungryScore != rhs._beforeHungryScore {return false}
    if lhs._afterHungryScore != rhs._afterHungryScore {return false}
    if lhs._feeling != rhs._feeling {return false}
    if lhs.mistakes != rhs.mistakes {return false}
    if lhs.isSkip != rhs.isSkip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V2_Diaries_Diary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Diary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "meta"),
    2: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _meta: Dta_Wed_Api_V2_Diaries_DiaryMeta? = nil
    var _data: Dta_Wed_Api_V2_Diaries_DiaryData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _meta = source._meta
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._meta) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._meta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V2_Diaries_Diary, rhs: Dta_Wed_Api_V2_Diaries_Diary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._meta != rhs_storage._meta {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V2_Diaries_CreateDiaryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDiaryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "date"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.date) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.date != 0 {
      try visitor.visitSingularInt32Field(value: self.date, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V2_Diaries_CreateDiaryRequest, rhs: Dta_Wed_Api_V2_Diaries_CreateDiaryRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.date != rhs.date {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V2_Diaries_UpdateDiaryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateDiaryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V2_Diaries_UpdateDiaryRequest, rhs: Dta_Wed_Api_V2_Diaries_UpdateDiaryRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V2_Diaries_GetDiariesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDiariesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "date"),
    3: .same(proto: "startDate"),
    4: .same(proto: "endDate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.date) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.startDate) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.endDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.date != 0 {
      try visitor.visitSingularInt32Field(value: self.date, fieldNumber: 2)
    }
    if self.startDate != 0 {
      try visitor.visitSingularInt32Field(value: self.startDate, fieldNumber: 3)
    }
    if self.endDate != 0 {
      try visitor.visitSingularInt32Field(value: self.endDate, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V2_Diaries_GetDiariesRequest, rhs: Dta_Wed_Api_V2_Diaries_GetDiariesRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.date != rhs.date {return false}
    if lhs.startDate != rhs.startDate {return false}
    if lhs.endDate != rhs.endDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dta_Wed_Api_V2_Diaries_GetDiariesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDiariesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startDate"),
    2: .same(proto: "endDate"),
    3: .same(proto: "diaries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.startDate) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.endDate) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.diaries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startDate != 0 {
      try visitor.visitSingularInt32Field(value: self.startDate, fieldNumber: 1)
    }
    if self.endDate != 0 {
      try visitor.visitSingularInt32Field(value: self.endDate, fieldNumber: 2)
    }
    if !self.diaries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.diaries, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dta_Wed_Api_V2_Diaries_GetDiariesResponse, rhs: Dta_Wed_Api_V2_Diaries_GetDiariesResponse) -> Bool {
    if lhs.startDate != rhs.startDate {return false}
    if lhs.endDate != rhs.endDate {return false}
    if lhs.diaries != rhs.diaries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
