// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: dta-wed-api/v2/diaries/diaries.proto

package diaries

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on DiaryFood with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DiaryFood) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DiaryFood with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DiaryFoodMultiError, or nil
// if none found.
func (m *DiaryFood) ValidateAll() error {
	return m.validate(true)
}

func (m *DiaryFood) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Text != nil {
		// no validation rules for Text
	}

	if len(errors) > 0 {
		return DiaryFoodMultiError(errors)
	}

	return nil
}

// DiaryFoodMultiError is an error wrapping multiple validation errors returned
// by DiaryFood.ValidateAll() if the designated constraints aren't met.
type DiaryFoodMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiaryFoodMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiaryFoodMultiError) AllErrors() []error { return m }

// DiaryFoodValidationError is the validation error returned by
// DiaryFood.Validate if the designated constraints aren't met.
type DiaryFoodValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiaryFoodValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiaryFoodValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiaryFoodValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiaryFoodValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiaryFoodValidationError) ErrorName() string { return "DiaryFoodValidationError" }

// Error satisfies the builtin error interface
func (e DiaryFoodValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiaryFood.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiaryFoodValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiaryFoodValidationError{}

// Validate checks the field values on DiaryFeelingEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DiaryFeelingEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DiaryFeelingEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DiaryFeelingEventMultiError, or nil if none found.
func (m *DiaryFeelingEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *DiaryFeelingEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetId(); val < 0 || val > 6 {
		err := DiaryFeelingEventValidationError{
			field:  "Id",
			reason: "value must be inside range [0, 6]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Text != nil {
		// no validation rules for Text
	}

	if len(errors) > 0 {
		return DiaryFeelingEventMultiError(errors)
	}

	return nil
}

// DiaryFeelingEventMultiError is an error wrapping multiple validation errors
// returned by DiaryFeelingEvent.ValidateAll() if the designated constraints
// aren't met.
type DiaryFeelingEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiaryFeelingEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiaryFeelingEventMultiError) AllErrors() []error { return m }

// DiaryFeelingEventValidationError is the validation error returned by
// DiaryFeelingEvent.Validate if the designated constraints aren't met.
type DiaryFeelingEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiaryFeelingEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiaryFeelingEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiaryFeelingEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiaryFeelingEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiaryFeelingEventValidationError) ErrorName() string {
	return "DiaryFeelingEventValidationError"
}

// Error satisfies the builtin error interface
func (e DiaryFeelingEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiaryFeelingEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiaryFeelingEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiaryFeelingEventValidationError{}

// Validate checks the field values on DiaryFeeling with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DiaryFeeling) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DiaryFeeling with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DiaryFeelingMultiError, or
// nil if none found.
func (m *DiaryFeeling) ValidateAll() error {
	return m.validate(true)
}

func (m *DiaryFeeling) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetScore(); val < 1 || val > 5 {
		err := DiaryFeelingValidationError{
			field:  "Score",
			reason: "value must be inside range [1, 5]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Event != nil {

		if all {
			switch v := interface{}(m.GetEvent()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DiaryFeelingValidationError{
						field:  "Event",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DiaryFeelingValidationError{
						field:  "Event",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEvent()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DiaryFeelingValidationError{
					field:  "Event",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DiaryFeelingMultiError(errors)
	}

	return nil
}

// DiaryFeelingMultiError is an error wrapping multiple validation errors
// returned by DiaryFeeling.ValidateAll() if the designated constraints aren't met.
type DiaryFeelingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiaryFeelingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiaryFeelingMultiError) AllErrors() []error { return m }

// DiaryFeelingValidationError is the validation error returned by
// DiaryFeeling.Validate if the designated constraints aren't met.
type DiaryFeelingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiaryFeelingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiaryFeelingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiaryFeelingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiaryFeelingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiaryFeelingValidationError) ErrorName() string { return "DiaryFeelingValidationError" }

// Error satisfies the builtin error interface
func (e DiaryFeelingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiaryFeeling.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiaryFeelingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiaryFeelingValidationError{}

// Validate checks the field values on DiaryFeelingScore with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DiaryFeelingScore) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DiaryFeelingScore with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DiaryFeelingScoreMultiError, or nil if none found.
func (m *DiaryFeelingScore) ValidateAll() error {
	return m.validate(true)
}

func (m *DiaryFeelingScore) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Score != nil {

		if val := m.GetScore(); val < 1 || val > 5 {
			err := DiaryFeelingScoreValidationError{
				field:  "Score",
				reason: "value must be inside range [1, 5]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Event != nil {
		// no validation rules for Event
	}

	if len(errors) > 0 {
		return DiaryFeelingScoreMultiError(errors)
	}

	return nil
}

// DiaryFeelingScoreMultiError is an error wrapping multiple validation errors
// returned by DiaryFeelingScore.ValidateAll() if the designated constraints
// aren't met.
type DiaryFeelingScoreMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiaryFeelingScoreMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiaryFeelingScoreMultiError) AllErrors() []error { return m }

// DiaryFeelingScoreValidationError is the validation error returned by
// DiaryFeelingScore.Validate if the designated constraints aren't met.
type DiaryFeelingScoreValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiaryFeelingScoreValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiaryFeelingScoreValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiaryFeelingScoreValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiaryFeelingScoreValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiaryFeelingScoreValidationError) ErrorName() string {
	return "DiaryFeelingScoreValidationError"
}

// Error satisfies the builtin error interface
func (e DiaryFeelingScoreValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiaryFeelingScore.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiaryFeelingScoreValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiaryFeelingScoreValidationError{}

// Validate checks the field values on DiarySchedule with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DiarySchedule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DiarySchedule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DiaryScheduleMultiError, or
// nil if none found.
func (m *DiarySchedule) ValidateAll() error {
	return m.validate(true)
}

func (m *DiarySchedule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	// no validation rules for Time

	if len(errors) > 0 {
		return DiaryScheduleMultiError(errors)
	}

	return nil
}

// DiaryScheduleMultiError is an error wrapping multiple validation errors
// returned by DiarySchedule.ValidateAll() if the designated constraints
// aren't met.
type DiaryScheduleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiaryScheduleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiaryScheduleMultiError) AllErrors() []error { return m }

// DiaryScheduleValidationError is the validation error returned by
// DiarySchedule.Validate if the designated constraints aren't met.
type DiaryScheduleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiaryScheduleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiaryScheduleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiaryScheduleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiaryScheduleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiaryScheduleValidationError) ErrorName() string { return "DiaryScheduleValidationError" }

// Error satisfies the builtin error interface
func (e DiaryScheduleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiarySchedule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiaryScheduleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiaryScheduleValidationError{}

// Validate checks the field values on DiaryMeta with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DiaryMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DiaryMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DiaryMetaMultiError, or nil
// if none found.
func (m *DiaryMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *DiaryMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if val := m.GetType(); val < 0 || val > 6 {
		err := DiaryMetaValidationError{
			field:  "Type",
			reason: "value must be inside range [0, 6]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Title

	// no validation rules for Description

	// no validation rules for Date

	if m.Emotion != nil {
		// no validation rules for Emotion
	}

	if m.Schedule != nil {

		if all {
			switch v := interface{}(m.GetSchedule()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DiaryMetaValidationError{
						field:  "Schedule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DiaryMetaValidationError{
						field:  "Schedule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSchedule()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DiaryMetaValidationError{
					field:  "Schedule",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DiaryMetaMultiError(errors)
	}

	return nil
}

// DiaryMetaMultiError is an error wrapping multiple validation errors returned
// by DiaryMeta.ValidateAll() if the designated constraints aren't met.
type DiaryMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiaryMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiaryMetaMultiError) AllErrors() []error { return m }

// DiaryMetaValidationError is the validation error returned by
// DiaryMeta.Validate if the designated constraints aren't met.
type DiaryMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiaryMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiaryMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiaryMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiaryMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiaryMetaValidationError) ErrorName() string { return "DiaryMetaValidationError" }

// Error satisfies the builtin error interface
func (e DiaryMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiaryMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiaryMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiaryMetaValidationError{}

// Validate checks the field values on DiaryData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DiaryData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DiaryData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DiaryDataMultiError, or nil
// if none found.
func (m *DiaryData) ValidateAll() error {
	return m.validate(true)
}

func (m *DiaryData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetType(); val < 0 || val > 6 {
		err := DiaryDataValidationError{
			field:  "Type",
			reason: "value must be inside range [0, 6]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsSkip

	if m.Time != nil {
		// no validation rules for Time
	}

	if m.Where != nil {
		// no validation rules for Where
	}

	if m.Food != nil {

		if all {
			switch v := interface{}(m.GetFood()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DiaryDataValidationError{
						field:  "Food",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DiaryDataValidationError{
						field:  "Food",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFood()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DiaryDataValidationError{
					field:  "Food",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.BeforeHungryScore != nil {

		if val := m.GetBeforeHungryScore(); val < 0 || val > 4 {
			err := DiaryDataValidationError{
				field:  "BeforeHungryScore",
				reason: "value must be inside range [0, 4]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.AfterHungryScore != nil {

		if val := m.GetAfterHungryScore(); val < 0 || val > 4 {
			err := DiaryDataValidationError{
				field:  "AfterHungryScore",
				reason: "value must be inside range [0, 4]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Feeling != nil {

		if all {
			switch v := interface{}(m.GetFeeling()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DiaryDataValidationError{
						field:  "Feeling",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DiaryDataValidationError{
						field:  "Feeling",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFeeling()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DiaryDataValidationError{
					field:  "Feeling",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DiaryDataMultiError(errors)
	}

	return nil
}

// DiaryDataMultiError is an error wrapping multiple validation errors returned
// by DiaryData.ValidateAll() if the designated constraints aren't met.
type DiaryDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiaryDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiaryDataMultiError) AllErrors() []error { return m }

// DiaryDataValidationError is the validation error returned by
// DiaryData.Validate if the designated constraints aren't met.
type DiaryDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiaryDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiaryDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiaryDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiaryDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiaryDataValidationError) ErrorName() string { return "DiaryDataValidationError" }

// Error satisfies the builtin error interface
func (e DiaryDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiaryData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiaryDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiaryDataValidationError{}

// Validate checks the field values on Diary with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Diary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Diary with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DiaryMultiError, or nil if none found.
func (m *Diary) ValidateAll() error {
	return m.validate(true)
}

func (m *Diary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Meta != nil {

		if all {
			switch v := interface{}(m.GetMeta()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DiaryValidationError{
						field:  "Meta",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DiaryValidationError{
						field:  "Meta",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DiaryValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Data != nil {

		if all {
			switch v := interface{}(m.GetData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DiaryValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DiaryValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DiaryValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DiaryMultiError(errors)
	}

	return nil
}

// DiaryMultiError is an error wrapping multiple validation errors returned by
// Diary.ValidateAll() if the designated constraints aren't met.
type DiaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiaryMultiError) AllErrors() []error { return m }

// DiaryValidationError is the validation error returned by Diary.Validate if
// the designated constraints aren't met.
type DiaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiaryValidationError) ErrorName() string { return "DiaryValidationError" }

// Error satisfies the builtin error interface
func (e DiaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiaryValidationError{}

// Validate checks the field values on CreateDiaryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDiaryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDiaryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDiaryRequestMultiError, or nil if none found.
func (m *CreateDiaryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDiaryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Date

	if m.Data != nil {

		if all {
			switch v := interface{}(m.GetData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateDiaryRequestValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateDiaryRequestValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateDiaryRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateDiaryRequestMultiError(errors)
	}

	return nil
}

// CreateDiaryRequestMultiError is an error wrapping multiple validation errors
// returned by CreateDiaryRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateDiaryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDiaryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDiaryRequestMultiError) AllErrors() []error { return m }

// CreateDiaryRequestValidationError is the validation error returned by
// CreateDiaryRequest.Validate if the designated constraints aren't met.
type CreateDiaryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDiaryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDiaryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDiaryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDiaryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDiaryRequestValidationError) ErrorName() string {
	return "CreateDiaryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDiaryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDiaryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDiaryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDiaryRequestValidationError{}

// Validate checks the field values on UpdateDiaryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDiaryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDiaryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDiaryRequestMultiError, or nil if none found.
func (m *UpdateDiaryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDiaryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.Data != nil {

		if all {
			switch v := interface{}(m.GetData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDiaryRequestValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDiaryRequestValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDiaryRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDiaryRequestMultiError(errors)
	}

	return nil
}

// UpdateDiaryRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateDiaryRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateDiaryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDiaryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDiaryRequestMultiError) AllErrors() []error { return m }

// UpdateDiaryRequestValidationError is the validation error returned by
// UpdateDiaryRequest.Validate if the designated constraints aren't met.
type UpdateDiaryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDiaryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDiaryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDiaryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDiaryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDiaryRequestValidationError) ErrorName() string {
	return "UpdateDiaryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDiaryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDiaryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDiaryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDiaryRequestValidationError{}

// Validate checks the field values on GetDiariesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetDiariesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDiariesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDiariesRequestMultiError, or nil if none found.
func (m *GetDiariesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDiariesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Date

	// no validation rules for StartDate

	// no validation rules for EndDate

	if len(errors) > 0 {
		return GetDiariesRequestMultiError(errors)
	}

	return nil
}

// GetDiariesRequestMultiError is an error wrapping multiple validation errors
// returned by GetDiariesRequest.ValidateAll() if the designated constraints
// aren't met.
type GetDiariesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDiariesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDiariesRequestMultiError) AllErrors() []error { return m }

// GetDiariesRequestValidationError is the validation error returned by
// GetDiariesRequest.Validate if the designated constraints aren't met.
type GetDiariesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDiariesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDiariesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDiariesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDiariesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDiariesRequestValidationError) ErrorName() string {
	return "GetDiariesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDiariesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDiariesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDiariesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDiariesRequestValidationError{}

// Validate checks the field values on GetDiariesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDiariesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDiariesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDiariesResponseMultiError, or nil if none found.
func (m *GetDiariesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDiariesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StartDate

	// no validation rules for EndDate

	for idx, item := range m.GetDiaries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDiariesResponseValidationError{
						field:  fmt.Sprintf("Diaries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDiariesResponseValidationError{
						field:  fmt.Sprintf("Diaries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDiariesResponseValidationError{
					field:  fmt.Sprintf("Diaries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetDiariesResponseMultiError(errors)
	}

	return nil
}

// GetDiariesResponseMultiError is an error wrapping multiple validation errors
// returned by GetDiariesResponse.ValidateAll() if the designated constraints
// aren't met.
type GetDiariesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDiariesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDiariesResponseMultiError) AllErrors() []error { return m }

// GetDiariesResponseValidationError is the validation error returned by
// GetDiariesResponse.Validate if the designated constraints aren't met.
type GetDiariesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDiariesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDiariesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDiariesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDiariesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDiariesResponseValidationError) ErrorName() string {
	return "GetDiariesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDiariesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDiariesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDiariesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDiariesResponseValidationError{}
